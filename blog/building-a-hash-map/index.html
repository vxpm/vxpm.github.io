<!doctype html><html lang=en><head><title>building a simple hash map - nulldark</title><meta charset=utf-8><meta content="vinícius x" name=author><meta content="hash maps are useful - let's build one!" name=description><meta content="width=device-width,initial-scale=1.0" name=viewport><link href=https://cdn.jsdelivr.net rel=preconnect><link href=https://fonts.googleapis.com rel=preconnect><link crossorigin href=https://fonts.gstatic.com rel=preconnect><link href=https://fonts.googleapis.com rel=dns-prefetch><link as=style href=https://viniciusx.com/styles.css rel=preload><link href="https://fonts.googleapis.com/css2?family=Cascadia+Code:ital,wght@0,200..700;1,200..700&family=Crimson+Pro:ital,wght@0,200..900;1,200..900&family=Space+Mono:ital,wght@0,400;0,700;1,400;1,700&display=swap" as=style rel=preload><link href="https://fonts.googleapis.com/css2?family=Cascadia+Code:wght@350&family=Crimson+Pro:ital,wght@0,200..900;1,200..900&family=Space+Mono:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel=stylesheet><link href=https://viniciusx.com/styles.css rel=stylesheet><script type=importmap>
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.178.0/+esm"
      }
    }
  </script><script crossorigin defer integrity=sha384-cMkvdD8LoxVzGF/RPUKAcvmm49FQ0oxwDF3BGKtDXcEc+T1b2N+teh/OJfpU0jr6 src=https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.js></script><script crossorigin defer integrity=sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh src=https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/contrib/auto-render.min.js></script><script defer src=https://viniciusx.com/main.js type=module></script><link crossorigin href=https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.css integrity=sha384-5TcZemv2l/9On385z///+d7MSYlvIEw9FuZTIdZ14vJLqWphw7e7ZPuOiCHJcFCP rel=stylesheet><link href=https://viniciusx.com/favicon-ico rel=icon><link href=https://viniciusx.com/favicon-32x32.png rel=icon sizes=32x32 type=image/png><link href=https://viniciusx.com/favicon-16x16.png rel=icon sizes=16x16 type=image/png><body><div class=container><div class=sidebar><div class=sidebar-title>nulldark</div><div class=sidebar-links><a href=https://viniciusx.com>about</a><a href=https://viniciusx.com/blog/>posts</a><a href=https://viniciusx.com/backyard/>backyard</a></div><div class=sidebar-canvas><canvas id=geometry-canvas></canvas></div><div class=sidebar-space></div><img class=sidebar-avatar src=https://viniciusx.com/processed_images/avatar.0f2cd7116fe229da.webp><div class=sidebar-description>too many ideas, too many projects and way too little time on my side</div></div><div class=content><div class=content-text><h1 class=post-title>building a simple hash map</h1><p class=post-info>hash maps are useful - let's build one! <br> 2025-07-31   ·   <a href=https://viniciusx.com/tags/data-structures/>data structures</a>   ·   <a href=https://viniciusx.com/tags/hash/>hash</a>   ·   <a href=https://viniciusx.com/tags/rust/>rust</a><div class=content-inline-toc><div class=toc-title>Table of Contents</div><ul><li><a href=https://viniciusx.com/blog/building-a-hash-map/#>Introduction</a><li><a href=https://viniciusx.com/blog/building-a-hash-map/#the-hash-in-the-map>The "hash" in the "map"</a><li><a href=https://viniciusx.com/blog/building-a-hash-map/#buckets>Buckets</a><li><a href=https://viniciusx.com/blog/building-a-hash-map/#implementation>Implementation</a> <ul><li><a href=https://viniciusx.com/blog/building-a-hash-map/#hash-related-traits>Hash related traits</a><li><a href=https://viniciusx.com/blog/building-a-hash-map/#borrowed-keys>Borrowed keys</a><li><a href=https://viniciusx.com/blog/building-a-hash-map/#capacity-growth>Capacity growth</a><li><a href=https://viniciusx.com/blog/building-a-hash-map/#insertion-and-querying>Insertion and Querying</a></ul><li><a href=https://viniciusx.com/blog/building-a-hash-map/#testing>Testing</a><li><a href=https://viniciusx.com/blog/building-a-hash-map/#should-you-use-this>Should you use this?</a></ul></div><div style=display:none>$$ \gdef \bigO #1{ \mathcal{O} \left( #1 \right) } $$</div><p>Hash Maps are like magic: you insert some (many, even) key-value pairs and, whenever you want, you can query the map with $\bigO{1}$ time complexity. It is stupidly useful!<sup class=footnote-reference id=fr-1-1><a href=#fn-1>1</a></sup> In fact, it's so useful that dynamic languages like <em>Lua</em> or <em>JavaScript</em> are essentially just a big pile of specialized hash maps.<p>But how does that even work? How is it able to search through so many elements in such a small time? And what better way to understand than to build one?<h2 id=the-hash-in-the-map><a aria-label="Anchor link for: the-hash-in-the-map" class=anchor-link href=#the-hash-in-the-map>#</a>The "hash" in the "map"</h2><p>Let's, first of all, try to define what we're trying to build. We want a data structure that is able to take a kv-pair and, somehow, just by looking at the key, know where to find it within some internal storage.<p>What we want is some kind of function $h(k)$ that can map any key we throw at it to a number, which we can then use to find the kv-pair in the storage. This is what we call the <em>hash function</em>, and the value it produces for a given key is it's <em>hash value</em> (often shortened to <em>hash</em>).<div class=post-image-container><img alt="An example of applying the hash function $h : \text{Strings} \to \text{Integers}$" class="post-image recolor" src=https://viniciusx.com/posts/building-a-hash-map/hash.svg><p class=post-image-alt>An example of applying the hash function $h : \text{Strings} \to \text{Integers}$</div><p>The hash value of a key is like an unique identifier for it - except it isn't unique. Different keys might have the same hash, no matter how similar or different they are. When that happens, we call it a <em>hash collision</em>.<p>We won't be discussing <em>how</em> to make a hash function, as our hash map will be generic over it. So understanding it's purpose is enough for us.<p>Well, cool. Now we have some sort of magical number unique-but-not-really to our key. How can we use it to find where the kv-pair is?<p>The idea is simple: we'll use the hash as an index into a buffer which stores the kv-pairs by computing the hash modulo the buffer length. There's just two problems:<ul><li>How do we deal with hash collisions?<li>How big should that buffer be?</ul><p>We'll answer both these questions with a single idea: buckets.<h2 id=buckets><a aria-label="Anchor link for: buckets" class=anchor-link href=#buckets>#</a>Buckets</h2><p>In order to solve hash collisions, our buffer can't<sup class=footnote-reference id=fr-2-1><a href=#fn-2>2</a></sup> just be a kv-pair buffer. Instead, we'll have it store groups of kv-pairs which ended up at the same index. Usually, these groups are called <em>buckets</em>. Therefore, our buffer is actually a buckets buffer.<div class=post-image-container><img alt="A diagram of the layout of the buffer. Each index contains a bucket, and each bucket
        contains multiple kv-pairs." class="post-image recolor" src=https://viniciusx.com/posts/building-a-hash-map/buckets.svg><p class=post-image-alt>A diagram of the layout of the buffer. Each index contains a bucket, and each bucket contains multiple kv-pairs.</div><p>Then, whenever we want to find a kv-pair, we compute the hash of the key to find it's bucket, and perform a linear search through the bucket to find the pair (if it is present).<p>Alright, hash collisions solved. How about the buffer size?<p>Remember our goal of $\bigO{1}$ time complexity: in order to achieve that, bucket size must be kept under a fixed limit, as we'll be performing a linear search for kv-pairs in them.<p>Assuming the hash function is of good quality and it's hash values are somewhat uniformely distributed (i.e. for any given key, all hash values have an equal probability of being it's hash), we can expect buckets to have around the same length.<p>With this, we can take a simple strategy: if we want to have around $N$ kv-pairs per bucket, we just need to ensure we have at most $N * (\text{bucket count})$ elements in our map. If we exceed that, we'll just double the bucket count.<h2 id=implementation><a aria-label="Anchor link for: implementation" class=anchor-link href=#implementation>#</a>Implementation</h2><p>Let's start by defining our <code>Map</code> struct:<pre class=language-rs data-lang=rs data-linenos style=color:#e8e8d3;background-color:#151515><code class=language-rs data-lang=rs><table><tbody><tr><td>1<td><span>use std::hash::RandomState;
</span><tr><td>2<td><span>
</span><tr><td>3<td><span style=color:#8fbfdc>pub struct </span><span style=color:#ffb964>Map</span><span>&lt;K, V, S = RandomState> {
</span><tr><td>4<td><span>    </span><span style=color:#ffb964>build_hasher</span><span>: S,
</span><tr><td>5<td><span>    </span><span style=color:#ffb964>buckets</span><span>: Vec&lt;Vec&lt;(K, V)>>,
</span><tr><td>6<td><span>    </span><span style=color:#ffb964>len</span><span>: </span><span style=color:#8fbfdc>usize</span><span>,
</span><tr><td>7<td><span>}
</span></table></code></pre><p>It has three generic parameters: <code>K</code>, the key type, <code>V</code>, the value type, and <code>S</code>, which is a type implementing the <a href=https://doc.rust-lang.org/stable/std/hash/struct.DefaultHasher.html><code>BuildHasher</code></a> trait (we don't add the trait bound in the definition, but we'll add it to the relevant <code>impl</code> blocks).<p>The fields are pretty self-explanatory, except for <code>build_hasher</code>, which is an instance of <code>S</code>. What even is the <a href=https://doc.rust-lang.org/stable/std/hash/struct.DefaultHasher.html><code>BuildHasher</code></a> trait, anyway?<h3 id=hash-related-traits><a aria-label="Anchor link for: hash-related-traits" class=anchor-link href=#hash-related-traits>#</a>Hash related traits</h3><p>The <a href=https://doc.rust-lang.org/stable/std/hash/struct.DefaultHasher.html><code>BuildHasher</code></a> trait is implemented by types which are able to produce instances of a type implementing the <a href=https://doc.rust-lang.org/stable/std/hash/trait.Hasher.html><code>Hasher</code></a> trait. The <a href=https://doc.rust-lang.org/stable/std/hash/trait.Hasher.html><code>Hasher</code></a> trait, on the other hand, is implemented by types which are able to hash an arbitrary stream of bytes, which in practice means they implement some hash function.<p>This is necessary because every <a href=https://doc.rust-lang.org/stable/std/hash/trait.Hasher.html><code>Hasher</code></a> has state, and we want to hash keys independently of one another, therefore we need to be able to create <a href=https://doc.rust-lang.org/stable/std/hash/trait.Hasher.html><code>Hasher</code></a>s whenever we want to hash something.<p>We also set <a href=https://doc.rust-lang.org/stable/std/hash/struct.RandomState.html><code>RandomState</code></a> as the default type for the <code>S</code> parameter, as it's the standard library's default <a href=https://doc.rust-lang.org/stable/std/hash/struct.DefaultHasher.html><code>BuildHasher</code></a>, producing <a href=https://doc.rust-lang.org/stable/std/hash/struct.DefaultHasher.html><code>DefaultHasher</code></a>s.<p>While we're talking about hash traits, let me talk about <a href=https://doc.rust-lang.org/stable/std/hash/trait.Hash.html><code>Hash</code></a> as well: types which implement <a href=https://doc.rust-lang.org/stable/std/hash/trait.Hash.html><code>Hash</code></a> know how to write their data to a <a href=https://doc.rust-lang.org/stable/std/hash/trait.Hasher.html><code>Hasher</code></a> in order to be hashed. Pretty simple.<h3 id=borrowed-keys><a aria-label="Anchor link for: borrowed-keys" class=anchor-link href=#borrowed-keys>#</a>Borrowed keys</h3><p>Let's implement some constructors:<pre class=language-rs data-lang=rs data-linenos style=color:#e8e8d3;background-color:#151515><code class=language-rs data-lang=rs><table><tbody><tr><td>1<td><span style=color:#8fbfdc>impl</span><span>&lt;K, V, S> </span><span style=color:#ffb964>Map</span><span>&lt;K, V, S>
</span><tr><td>2<td><span>{
</span><tr><td>3<td><span>    </span><span style=color:#888>/// Creates a new [`Map`] with the given [`Hasher`] builder.
</span><tr><td>4<td><span>    </span><span style=color:#8fbfdc>pub fn </span><span style=color:#fad07a>with_hasher</span><span>(</span><span style=color:#ffb964>build_hasher</span><span>: S) -> </span><span style=color:#8fbfdc>Self </span><span>{
</span><tr><td>5<td><span>        </span><span style=color:#8fbfdc>Self </span><span>{
</span><tr><td>6<td><span>            build_hasher,
</span><tr><td>7<td><span>            buckets: Vec::new(),
</span><tr><td>8<td><span>            len: </span><span style=color:#cf6a4c>0</span><span>,
</span><tr><td>9<td><span>        }
</span><tr><td>10<td><span>    }
</span><tr><td>11<td><span>}
</span><tr><td>12<td><span>
</span><tr><td>13<td><span style=color:#888>// Note: This is only implemented for Map&lt;K, V, RandomState>!
</span><tr><td>14<td><span style=color:#8fbfdc>impl</span><span>&lt;K, V> </span><span style=color:#ffb964>Map</span><span>&lt;K, V> {
</span><tr><td>15<td><span>    </span><span style=color:#888>/// Creates a new [`Map`] with the default [`BuildHasher`].
</span><tr><td>16<td><span>    </span><span style=color:#8fbfdc>pub fn </span><span style=color:#fad07a>new</span><span>() -> </span><span style=color:#8fbfdc>Self </span><span>{
</span><tr><td>17<td><span>        </span><span style=color:#8fbfdc>Self</span><span>::with_hasher(Default::default())
</span><tr><td>18<td><span>    }
</span><tr><td>19<td><span>}
</span></table></code></pre><p>These constructors are pretty simple - nothing too fancy going on. Let's start implementing some of the more interesting functionality of the map:<pre class=language-rs data-lang=rs data-linenos style=color:#e8e8d3;background-color:#151515><code class=language-rs data-lang=rs><table><tbody><tr><td>1<td><span>use std::hash::{Hash, BuildHasher};
</span><tr><td>2<td><span>use std::borrow::Borrow;
</span><tr><td>3<td><span>
</span><tr><td>4<td><span style=color:#888>// From now on, assume all method definitions to be within this impl block
</span><tr><td>5<td><span style=color:#8fbfdc>impl</span><span>&lt;K, V, S> </span><span style=color:#ffb964>Map</span><span>&lt;K, V, S>
</span><tr><td>6<td><span>where
</span><tr><td>7<td><span>    K: Hash + Eq,
</span><tr><td>8<td><span>    S: BuildHasher,
</span><tr><td>9<td><span>{
</span><tr><td>10<td><span>    </span><span style=color:#888>/// Given a key, returns the index of the bucket it belongs to.
</span><tr><td>11<td><span>    </span><span style=color:#8fbfdc>fn </span><span style=color:#fad07a>bucket_for</span><span>&lt;Q>(&</span><span style=color:#ffb964>self</span><span>, </span><span style=color:#ffb964>key</span><span>: &Q) -> </span><span style=color:#8fbfdc>usize
</span><tr><td>12<td><span>    where
</span><tr><td>13<td><span>        K: Borrow&lt;Q>,
</span><tr><td>14<td><span>        Q: Hash + ?Sized,
</span><tr><td>15<td><span>    {
</span><tr><td>16<td><span>        </span><span style=color:#8fbfdc>let mut</span><span> hasher = </span><span style=color:#ffb964>self</span><span>.build_hasher.build_hasher();
</span><tr><td>17<td><span>        key.hash(&</span><span style=color:#8fbfdc>mut</span><span> hasher);
</span><tr><td>18<td><span>
</span><tr><td>19<td><span>        (hasher.finish() as </span><span style=color:#8fbfdc>usize</span><span>) % </span><span style=color:#ffb964>self</span><span>.buckets.len()
</span><tr><td>20<td><span>    }
</span><tr><td>21<td><span>}
</span></table></code></pre><p>The <code>bucket_for</code> method has an unexpected type parameter <code>Q</code> - what is that for?<p>We want to be able to query the map with borrowed representations of <code>K</code> as well - not just owned ones. Imagine if, in order to query a <code>Map&lt;String, _></code>, you had to allocate a <code>String</code> even if you already had a <code>&str</code>. That wouldn't be ideal - and that's what we're avoiding here.<p>The <a href=https://doc.rust-lang.org/stable/std/borrow/trait.Borrow.html><code>Borrow&lt;T></code></a> trait essentially says that it's implementor can be borrowed as a <code>T</code> and, per it's docs, stablishes a contract that the <a href=https://doc.rust-lang.org/stable/std/cmp/trait.Eq.html><code>Eq</code></a>, <a href=https://doc.rust-lang.org/stable/std/cmp/trait.Ord.html><code>Ord</code></a> and <a href=https://doc.rust-lang.org/stable/std/hash/trait.Hash.html><code>Hash</code></a> traits behave identically on both types. This allows us to hash the <code>Q</code> we received and treat it's hash as the same hash of a <code>K</code> which would borrow to that value.<h3 id=capacity-growth><a aria-label="Anchor link for: capacity-growth" class=anchor-link href=#capacity-growth>#</a>Capacity growth</h3><pre class=language-rs data-lang=rs data-linenos style=color:#e8e8d3;background-color:#151515><code class=language-rs data-lang=rs><table><tbody><tr><td>1<td><span style=color:#888>/// Grows the map by doubling it's capacity
</span><tr><td>2<td><span style=color:#8fbfdc>fn </span><span style=color:#fad07a>grow</span><span>(&</span><span style=color:#8fbfdc>mut </span><span style=color:#ffb964>self</span><span>) {
</span><tr><td>3<td><span>    </span><span style=color:#8fbfdc>let</span><span> old_bucket_count = </span><span style=color:#ffb964>self</span><span>.buckets.len();
</span><tr><td>4<td><span>    </span><span style=color:#8fbfdc>let</span><span> new_bucket_count = (</span><span style=color:#ffb964>self</span><span>.buckets.len() * </span><span style=color:#cf6a4c>2</span><span>).max(</span><span style=color:#cf6a4c>4</span><span>);
</span><tr><td>5<td><span>    </span><span style=color:#ffb964>self</span><span>.buckets.resize_with(new_bucket_count, Vec::new);
</span><tr><td>6<td><span>
</span><tr><td>7<td><span>    </span><span style=color:#888>// Rehash and move pairs around
</span><tr><td>8<td><span>    </span><span style=color:#8fbfdc>for</span><span> check_bucket in </span><span style=color:#cf6a4c>0</span><span>..old_bucket_count {
</span><tr><td>9<td><span>        </span><span style=color:#8fbfdc>let mut</span><span> index = </span><span style=color:#cf6a4c>0</span><span>;
</span><tr><td>10<td><span>        </span><span style=color:#8fbfdc>while</span><span> index &lt; </span><span style=color:#ffb964>self</span><span>.buckets[check_bucket].len() {
</span><tr><td>11<td><span>            </span><span style=color:#8fbfdc>let</span><span> correct_bucket = </span><span style=color:#ffb964>self</span><span>.bucket_for(&</span><span style=color:#ffb964>self</span><span>.buckets[check_bucket][index].</span><span style=color:#cf6a4c>0</span><span>);
</span><tr><td>12<td><span>            </span><span style=color:#8fbfdc>if</span><span> correct_bucket != check_bucket {
</span><tr><td>13<td><span>                </span><span style=color:#8fbfdc>let</span><span> pair = </span><span style=color:#ffb964>self</span><span>.buckets[check_bucket].swap_remove(index);
</span><tr><td>14<td><span>                </span><span style=color:#ffb964>self</span><span>.buckets[correct_bucket].push(pair);
</span><tr><td>15<td><span>            } </span><span style=color:#8fbfdc>else </span><span>{
</span><tr><td>16<td><span>                index += </span><span style=color:#cf6a4c>1</span><span>;
</span><tr><td>17<td><span>            }
</span><tr><td>18<td><span>        }
</span><tr><td>19<td><span>    }
</span><tr><td>20<td><span>}
</span></table></code></pre><p><code>grow</code> is the method we'll be calling whenever the map gets too full.<p>It starts by computing the new size as <code>(self.buckets.len() * 2).max(4)</code> which in practice means "double the length, and make it at least four"<sup class=footnote-reference id=fr-3-1><a href=#fn-3>3</a></sup>, then resizing the buckets buffer to that size.<p>Then, since the length of the buffer changed, we need to rehash the kv-pairs already present, since their buckets have likely changed (their hash remains the same, but the resulting bucket after applying the modulo may have not).<p>The way we do it is a little convoluted, but not very hard to grasp:<ul><li>Iterate over the buckets that were already present before growing<li>For each bucket, iterate over the elements, rehash their keys and then move them if their bucket has changed</ul><p>The iteration over the elements is done through a while loop with an index that only gets incremented if the element is in the correct bucket, because if it isn't, we're going to remove it and the element at the current index will change (so we need to keep the index the same in order to check it).<h3 id=insertion-and-querying><a aria-label="Anchor link for: insertion-and-querying" class=anchor-link href=#insertion-and-querying>#</a>Insertion and Querying</h3><pre class=language-rs data-lang=rs data-linenos style=color:#e8e8d3;background-color:#151515><code class=language-rs data-lang=rs><table><tbody><tr><td>1<td><span style=color:#888>// Could be any number but 8 seems like a good compromise
</span><tr><td>2<td><span style=color:#8fbfdc>const </span><span style=color:#7697d6>BUCKET_SIZE</span><span>: </span><span style=color:#8fbfdc>usize </span><span>= </span><span style=color:#cf6a4c>8</span><span>;
</span><tr><td>3<td><span>
</span><tr><td>4<td><span style=color:#888>/// Inserts a key-value pair into the map, returning the old value if
</span><tr><td>5<td><span style=color:#888>/// the key was already present.
</span><tr><td>6<td><span style=color:#8fbfdc>pub fn </span><span style=color:#fad07a>insert</span><span>(&</span><span style=color:#8fbfdc>mut </span><span style=color:#ffb964>self</span><span>, </span><span style=color:#ffb964>key</span><span>: K, </span><span style=color:#ffb964>value</span><span>: V) -> Option&lt;V> {
</span><tr><td>7<td><span>    </span><span style=color:#888>// Special case for when the map is empty (no buckets)
</span><tr><td>8<td><span>    </span><span style=color:#8fbfdc>if </span><span style=color:#ffb964>self</span><span>.buckets.is_empty() {
</span><tr><td>9<td><span>        </span><span style=color:#ffb964>self</span><span>.grow();
</span><tr><td>10<td><span>
</span><tr><td>11<td><span>        </span><span style=color:#8fbfdc>let</span><span> bucket = </span><span style=color:#ffb964>self</span><span>.bucket_for(&key);
</span><tr><td>12<td><span>        </span><span style=color:#ffb964>self</span><span>.buckets[bucket].push((key, value));
</span><tr><td>13<td><span>        </span><span style=color:#ffb964>self</span><span>.len += </span><span style=color:#cf6a4c>1</span><span>;
</span><tr><td>14<td><span>
</span><tr><td>15<td><span>        </span><span style=color:#8fbfdc>return </span><span>None;
</span><tr><td>16<td><span>    }
</span><tr><td>17<td><span>
</span><tr><td>18<td><span>    </span><span style=color:#8fbfdc>let</span><span> bucket = </span><span style=color:#ffb964>self</span><span>.bucket_for(&key);
</span><tr><td>19<td><span>    </span><span style=color:#8fbfdc>let</span><span> pair = </span><span style=color:#ffb964>self</span><span>.buckets[bucket].iter_mut().find(|(</span><span style=color:#ffb964>k</span><span>, _)| *k == key);
</span><tr><td>20<td><span>    </span><span style=color:#8fbfdc>match</span><span> pair {
</span><tr><td>21<td><span>        Some((_, v)) => Some(std::mem::replace(v, value)),
</span><tr><td>22<td><span>        None => {
</span><tr><td>23<td><span>            </span><span style=color:#ffb964>self</span><span>.buckets[bucket].push((key, value));
</span><tr><td>24<td><span>            </span><span style=color:#ffb964>self</span><span>.len += </span><span style=color:#cf6a4c>1</span><span>;
</span><tr><td>25<td><span>
</span><tr><td>26<td><span>            </span><span style=color:#888>// Check if we have more than BUCKET_SIZE elements per bucket
</span><tr><td>27<td><span>            </span><span style=color:#888>// (on average) and then grow if that's the case
</span><tr><td>28<td><span>            </span><span style=color:#8fbfdc>if Self</span><span>::</span><span style=color:#7697d6>BUCKET_SIZE </span><span>* </span><span style=color:#ffb964>self</span><span>.buckets.len() &lt; </span><span style=color:#ffb964>self</span><span>.len {
</span><tr><td>29<td><span>                </span><span style=color:#ffb964>self</span><span>.grow();
</span><tr><td>30<td><span>            }
</span><tr><td>31<td><span>
</span><tr><td>32<td><span>            None
</span><tr><td>33<td><span>        }
</span><tr><td>34<td><span>    }
</span><tr><td>35<td><span>}
</span></table></code></pre><p>Inserting into the map is pretty straightforward: compute the bucket for the key, search for the key in the bucket and then replace the value of the pair if it is present or insert the new pair otherwise. We also handle the special case where the buckets buffer is empty.<pre class=language-rs data-lang=rs data-linenos style=color:#e8e8d3;background-color:#151515><code class=language-rs data-lang=rs><table><tbody><tr><td>1<td><span style=color:#888>/// Returns the value associated with the given key.
</span><tr><td>2<td><span style=color:#8fbfdc>pub fn </span><span style=color:#fad07a>get</span><span>&lt;Q>(&</span><span style=color:#ffb964>self</span><span>, </span><span style=color:#ffb964>key</span><span>: &Q) -> Option&lt;&V>
</span><tr><td>3<td><span>where
</span><tr><td>4<td><span>    K: Borrow&lt;Q>,
</span><tr><td>5<td><span>    Q: Hash + Eq + ?Sized,
</span><tr><td>6<td><span>{
</span><tr><td>7<td><span>    </span><span style=color:#8fbfdc>let</span><span> bucket = </span><span style=color:#ffb964>self</span><span>.bucket_for(key);
</span><tr><td>8<td><span>    </span><span style=color:#ffb964>self</span><span>.buckets[bucket]
</span><tr><td>9<td><span>        .iter()
</span><tr><td>10<td><span>        .find_map(|</span><span style=color:#ffb964>pair</span><span>| (key == pair.</span><span style=color:#cf6a4c>0.</span><span>borrow()).then_some(&pair.</span><span style=color:#cf6a4c>1</span><span>))
</span><tr><td>11<td><span>}
</span></table></code></pre><p>Querying the map is <em>even more</em> straightforward! We just compute the bucket for the key, search for the key in the bucket and return it's associated value if it is present.<p>Notice that, just like <code>bucket_for</code>, <code>get</code> has a generic parameter <code>Q</code> which we use instead of <code>K</code> for all the same reasons I listed before.<p>And with that, you have a simple hash map! Sure, it's missing important methods like <code>remove</code>, but I'll leave them as an exercise for the reader.<p>It's important to note that this is <em>not</em> the only way to build a hash map. There are way too many ways to build one, actually. This is just the one I chose to implement in this post!<h2 id=testing><a aria-label="Anchor link for: testing" class=anchor-link href=#testing>#</a>Testing</h2><p>Does it really work? Let's test it!<p>First, we'll implement <a href=https://doc.rust-lang.org/stable/std/fmt/trait.Debug.html><code>Debug</code></a> in order to see what the map contains:<pre class=language-rs data-lang=rs data-linenos style=color:#e8e8d3;background-color:#151515><code class=language-rs data-lang=rs><table><tbody><tr><td>1<td><span style=color:#8fbfdc>impl</span><span>&lt;K, V, S> Debug for </span><span style=color:#ffb964>Map</span><span>&lt;K, V, S>
</span><tr><td>2<td><span>where
</span><tr><td>3<td><span>    K: Debug,
</span><tr><td>4<td><span>    V: Debug,
</span><tr><td>5<td><span>{
</span><tr><td>6<td><span>    </span><span style=color:#8fbfdc>fn </span><span style=color:#fad07a>fmt</span><span>(&</span><span style=color:#ffb964>self</span><span>, </span><span style=color:#ffb964>f</span><span>: &</span><span style=color:#8fbfdc>mut </span><span>std::fmt::Formatter&lt;'_>) -> std::fmt::Result {
</span><tr><td>7<td><span>        </span><span style=color:#8fbfdc>let mut</span><span> d = f.debug_map();
</span><tr><td>8<td><span>        </span><span style=color:#8fbfdc>for</span><span> pair in </span><span style=color:#ffb964>self</span><span>.buckets.iter().flat_map(|</span><span style=color:#ffb964>b</span><span>| b.iter()) {
</span><tr><td>9<td><span>            d.entry(&pair.</span><span style=color:#cf6a4c>0</span><span>, &pair.</span><span style=color:#cf6a4c>1</span><span>);
</span><tr><td>10<td><span>        }
</span><tr><td>11<td><span>
</span><tr><td>12<td><span>        d.finish()
</span><tr><td>13<td><span>    }
</span><tr><td>14<td><span>}
</span></table></code></pre><p>Then, we'll write a very simple test:<pre class=language-rs data-lang=rs data-linenos style=color:#e8e8d3;background-color:#151515><code class=language-rs data-lang=rs><table><tbody><tr><td>1<td><span>#[</span><span style=color:#ffb964>test</span><span>]
</span><tr><td>2<td><span style=color:#8fbfdc>fn </span><span style=color:#fad07a>map_test</span><span>() {
</span><tr><td>3<td><span>    </span><span style=color:#8fbfdc>let mut</span><span> map = Map::new();
</span><tr><td>4<td><span>    map.insert(</span><span style=color:#563>"</span><span style=color:#99ad6a>pi</span><span style=color:#563>"</span><span>, </span><span style=color:#cf6a4c>31415</span><span>);
</span><tr><td>5<td><span>    map.insert(</span><span style=color:#563>"</span><span style=color:#99ad6a>answer</span><span style=color:#563>"</span><span>, </span><span style=color:#cf6a4c>42</span><span>);
</span><tr><td>6<td><span>    map.insert(</span><span style=color:#563>"</span><span style=color:#99ad6a>nine</span><span style=color:#563>"</span><span>, </span><span style=color:#cf6a4c>4</span><span>);
</span><tr><td>7<td><span>
</span><tr><td>8<td><span>    assert!(matches!(map.get(</span><span style=color:#563>"</span><span style=color:#99ad6a>pi</span><span style=color:#563>"</span><span>), Some(</span><span style=color:#cf6a4c>31415</span><span>)));
</span><tr><td>9<td><span>    assert!(matches!(map.get(</span><span style=color:#563>"</span><span style=color:#99ad6a>answer</span><span style=color:#563>"</span><span>), Some(</span><span style=color:#cf6a4c>42</span><span>)));
</span><tr><td>10<td><span>    assert!(matches!(map.get(</span><span style=color:#563>"</span><span style=color:#99ad6a>nine</span><span style=color:#563>"</span><span>), Some(</span><span style=color:#cf6a4c>4</span><span>)));
</span><tr><td>11<td><span>
</span><tr><td>12<td><span>    assert!(!matches!(map.get(</span><span style=color:#563>"</span><span style=color:#99ad6a>pi</span><span style=color:#563>"</span><span>), Some(</span><span style=color:#cf6a4c>1</span><span>)));
</span><tr><td>13<td><span>    assert!(!matches!(map.get(</span><span style=color:#563>"</span><span style=color:#99ad6a>answer</span><span style=color:#563>"</span><span>), None));
</span><tr><td>14<td><span>    assert!(!matches!(map.get(</span><span style=color:#563>"</span><span style=color:#99ad6a>nine</span><span style=color:#563>"</span><span>), Some(</span><span style=color:#cf6a4c>31415</span><span>)));
</span><tr><td>15<td><span>
</span><tr><td>16<td><span>    assert!(map.get(</span><span style=color:#563>"</span><span style=color:#99ad6a>foo</span><span style=color:#563>"</span><span>).is_none());
</span><tr><td>17<td><span>    assert!(map.get(</span><span style=color:#563>"</span><span style=color:#99ad6a>bar</span><span style=color:#563>"</span><span>).is_none());
</span><tr><td>18<td><span>    assert!(map.get(</span><span style=color:#563>"</span><span style=color:#99ad6a>baz</span><span style=color:#563>"</span><span>).is_none());
</span><tr><td>19<td><span>
</span><tr><td>20<td><span>    dbg!(&map);
</span><tr><td>21<td><span>}
</span></table></code></pre><p>And...<pre style=color:#e8e8d3;background-color:#151515><code><span>running 1 test
</span><span>test map_test ... ok
</span><span>
</span><span>---- map_test stdout ----
</span><span>[src/lib.rs:156:5] &map = {
</span><span>    "pi": 31415,
</span><span>    "answer": 42,
</span><span>    "nine": 4,
</span><span>}
</span></code></pre><p>Cool! It actually works!<h2 id=should-you-use-this><a aria-label="Anchor link for: should-you-use-this" class=anchor-link href=#should-you-use-this>#</a>Should you use this?</h2><p>No. Use the standard library's hash map. Or some other actually good one. The one we just built is, honestly, pretty bad. It could be improved in many ways, even without changing it's architecture much. But it's easy to understand, so there's that!<p>The simplest optimization you could implement is replacing the type of the buckets <code>Vec&lt;(K, V)></code> with <code>SmallVec&lt;[(K, V); 2 * Self::BUCKET_SIZE]></code>. This will make our map more cache friendly, as we remove the added indirection of the <code>Vec</code> in the majority of cases (<a href=https://docs.rs/smallvec/latest/smallvec/struct.SmallVec.html><code>SmallVec</code></a> will allocate if the inline storage isn't enough).<p>I hope you learned something new, though! Have fun hashing stuff.<section class=footnotes><ol class=footnotes-list><li id=fn-1><p>Note, however, that constant time complexity does not mean "fast!!!!!" - it just means the time it takes does not grow with input size (in this case, the map size). A linear search on an array is still faster for small enough (which is very relative) collections. <a href=#fr-1-1>↩</a></p><li id=fn-2><p>I lied - it can. But that's not the approach I'll be following in this post. You can read more about it by searching for the "Open Addressing Strategy" for collision resolution. <a href=#fr-2-1>↩</a></p><li id=fn-3><p>Although the <code>max</code> method makes it look like we're stablishing a maximum value for the expression, that's not the case! It's evaluating to the <em>maximum</em> between the two values, i.e. <code>a.max(b)</code> is the same as <code>max(a, b)</code>. <a href=https://doc.rust-lang.org/stable/std/cmp/trait.Ord.html#method.max>Docs</a>. <a href=#fr-3-1>↩</a></p></ol></section><div class=giscus><script crossorigin data-category=Announcements data-category-id=DIC_kwDOPWTjcs4Ctpqu data-emit-metadata=0 data-input-position=top data-lang=en data-loading=lazy data-mapping=pathname data-reactions-enabled=0 data-repo=vxpm/vxpm.github.io data-repo-id=R_kgDOPWTjcg data-strict=1 data-theme=dark defer src=https://giscus.app/client.js></script></div></div><div class=content-side-toc><div class=toc-title>Table of Contents</div><ul><li><a href=https://viniciusx.com/blog/building-a-hash-map/#>Introduction</a><li><a href=https://viniciusx.com/blog/building-a-hash-map/#the-hash-in-the-map>The "hash" in the "map"</a><li><a href=https://viniciusx.com/blog/building-a-hash-map/#buckets>Buckets</a><li><a href=https://viniciusx.com/blog/building-a-hash-map/#implementation>Implementation</a> <ul><li><a href=https://viniciusx.com/blog/building-a-hash-map/#hash-related-traits>Hash related traits</a><li><a href=https://viniciusx.com/blog/building-a-hash-map/#borrowed-keys>Borrowed keys</a><li><a href=https://viniciusx.com/blog/building-a-hash-map/#capacity-growth>Capacity growth</a><li><a href=https://viniciusx.com/blog/building-a-hash-map/#insertion-and-querying>Insertion and Querying</a></ul><li><a href=https://viniciusx.com/blog/building-a-hash-map/#testing>Testing</a><li><a href=https://viniciusx.com/blog/building-a-hash-map/#should-you-use-this>Should you use this?</a></ul></div></div></div>